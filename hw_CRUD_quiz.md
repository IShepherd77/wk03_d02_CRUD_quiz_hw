# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the `Property` class?

in the console.rb file e.g.

property1 = Property.new({
  'address' => '89 Bouverie Road, WESTON UNDER WETHERLEY, CV33 3XG',
  'value' => 120000,
  'bedrooms' => 3,
  'build' => 'detached'
  })

Q2. Where are we defining the SQL that enables us to save the ruby `Property` object into the database?

in the def save function in the property.rb file where the "sql = " line and between the quotes e.g
sql = "INSERT INTO properties
    (
      address,
      value,
      bedrooms,
      build
    )
    VALUES
    (
      $1,$2,$3,$4
    )
    RETURNING id"

Q3. In `console.rb`, which lines modify the database?


Any of the delete or save methods e.g.
Property.delete_all()
property1.delete()
property1.save()


Q4. Why do we not define the id of a `Property` object at the point we instantiate it (‘new it up’)?

Technically I think you could but there is no need to as you are setting this up to generate an automatic unique id ref
in the .sql file when setting up the CREATE TABLE section and defining id SERIAL4 PRIMARY KEY.
Getting the system to auto-generate the unique identifier is not only less work but also safer and avoids any errors
or potential duplication.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby `Property` object?

in the section of code below.  We create and instance variable called id which equals the db.exec_prepared line of code
below and which saves each row / record / values in first column with a column name of "id" which is converted to an integer.

RETURNING id"
    values = [@address, @value, @bedrooms, @build]
    db.prepare("save", sql)
    @id = db.exec_prepared("save", values)[0]["id"].to_i

Q6. Why do we put a guard (an `if` clause) on the `@id` attribute in the constructor?

It prevents us from having to create a separate id in an instance of properties and makes sure that the id the database creates is maintained.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?

  the Class.methods such as Property.all require access to all the information within the class.  
  the instance methods such as def update() or def delete() just need access to the instance data

Q8. What type of data structure is returned by calls to `db.exec_prepared()`? In the `save` method, how do we access the id from the returned data structure?

I think it is an array data structure which is returned.

We are accessing the id via the [0] index of the array then naming the "id" as a string which is then converted to an integer using the [0]["id"].to_i

Q9. Why do we use prepared statements when performing database operations?

To prevent SQL injection and prevent users from manipulating the data / database

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the `Property` class.

Q10. What do they take in as their arguments?

They look to take [id] and [address] as their arguments

Q11. What are their return values?

it will return all the data (column / row) on the line for either the [id] or whether searched by [address]
depending which one was searched for.
they will return nil if invalid parameter entered in the find or one result if a match.
it will return it as a new instance as a hash
